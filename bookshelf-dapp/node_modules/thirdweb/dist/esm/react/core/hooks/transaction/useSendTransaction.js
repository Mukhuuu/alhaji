import { useMutation } from "@tanstack/react-query";
import { getContract } from "../../../../contract/contract.js";
import { getCurrencyMetadata } from "../../../../extensions/erc20/read/getCurrencyMetadata.js";
import { getGasPrice } from "../../../../gas/get-gas-price.js";
import { estimateGasCost } from "../../../../transaction/actions/estimate-gas-cost.js";
import { sendTransaction } from "../../../../transaction/actions/send-transaction.js";
import { resolvePromisedValue } from "../../../../utils/promise/resolve-promised-value.js";
import { getWalletBalance, } from "../../../../wallets/utils/getWalletBalance.js";
import { fetchBuySupportedDestinations } from "../../../web/ui/ConnectWallet/screens/Buy/swap/useSwapSupportedChains.js";
/**
 * A hook to send a transaction.
 * @returns A mutation object to send a transaction.
 * @example
 * ```jsx
 * import { useSendTransaction } from "thirdweb/react";
 * const { mutate: sendTx, data: transactionResult } = useSendTransaction();
 *
 * // later
 * sendTx(tx);
 * ```
 * @internal
 */
export function useSendTransactionCore(args) {
    const { showPayModal, gasless, wallet, switchChain } = args;
    let _account = wallet?.getAccount();
    return useMutation({
        mutationFn: async (tx) => {
            // switch chain if needed
            if (wallet && tx.chain.id !== wallet.getChain()?.id) {
                await switchChain(tx.chain);
                // in smart wallet case, account may change after chain switch
                _account = wallet.getAccount();
            }
            const account = _account;
            if (!account) {
                throw new Error("No active account");
            }
            if (!showPayModal) {
                return sendTransaction({
                    transaction: tx,
                    account,
                    gasless,
                });
            }
            return new Promise((resolve, reject) => {
                const sendTx = async () => {
                    try {
                        const res = await sendTransaction({
                            transaction: tx,
                            account,
                            gasless,
                        });
                        resolve(res);
                    }
                    catch (e) {
                        reject(e);
                    }
                };
                (async () => {
                    try {
                        const destinations = await fetchBuySupportedDestinations(tx.client);
                        const isBuySupported = destinations.find((c) => c.chain.id === tx.chain.id);
                        // buy not supported, can't show modal - send tx directly
                        if (!isBuySupported) {
                            sendTx();
                            return;
                        }
                        //  buy supported, check if there is enough balance - if not show modal to buy tokens
                        const [nativeWalletBalance, nativeCostWei] = await Promise.all([
                            getWalletBalance({
                                address: account.address,
                                chain: tx.chain,
                                client: tx.client,
                            }),
                            getTotalTxCostForBuy(tx, account?.address),
                        ]);
                        let currency = undefined;
                        let walletBalance = nativeWalletBalance;
                        let totalCostWei = nativeCostWei;
                        const hasEnoughForGas = nativeWalletBalance.value > nativeCostWei;
                        const erc20Value = await resolvePromisedValue(tx.erc20Value);
                        if (erc20Value && hasEnoughForGas) {
                            const [tokenBalance, tokenMeta] = await Promise.all([
                                getWalletBalance({
                                    address: account.address,
                                    chain: tx.chain,
                                    client: tx.client,
                                    tokenAddress: erc20Value.tokenAddress,
                                }),
                                getCurrencyMetadata({
                                    contract: getContract({
                                        address: erc20Value.tokenAddress,
                                        chain: tx.chain,
                                        client: tx.client,
                                    }),
                                }),
                            ]);
                            totalCostWei = erc20Value.amountWei;
                            walletBalance = tokenBalance;
                            currency = {
                                address: erc20Value.tokenAddress,
                                name: tokenMeta.name,
                                symbol: tokenMeta.symbol,
                                decimals: tokenMeta.decimals,
                            };
                        }
                        // if enough balance, send tx
                        if (totalCostWei < walletBalance.value) {
                            sendTx();
                            return;
                        }
                        // if not enough balance - show modal
                        showPayModal({
                            tx,
                            sendTx,
                            rejectTx: reject,
                            resolveTx: resolve,
                            totalCostWei,
                            walletBalance,
                            currency,
                        });
                    }
                    catch (e) {
                        console.error("Failed to estimate cost", e);
                        // send it anyway?
                        sendTx();
                    }
                })();
            });
        },
    });
}
export async function getTotalTxCostForBuy(tx, from) {
    try {
        const gasCost = await estimateGasCost({
            transaction: tx,
            from,
        });
        const bufferCost = gasCost.wei / 10n;
        // Note: get tx.value AFTER estimateGasCost
        const txValue = await resolvePromisedValue(tx.value);
        // add 10% extra gas cost to the estimate to ensure user buys enough to cover the tx cost
        return gasCost.wei + bufferCost + (txValue || 0n);
    }
    catch (e) {
        if (from) {
            // try again without passing from
            return await getTotalTxCostForBuy(tx);
        }
        // fallback if both fail, use the tx value + 2M * gas price
        const value = await resolvePromisedValue(tx.value);
        const gasPrice = await getGasPrice({
            client: tx.client,
            chain: tx.chain,
        });
        const buffer = 2000000n * gasPrice;
        if (!value) {
            return 0n + buffer;
        }
        return value + buffer;
    }
}
//# sourceMappingURL=useSendTransaction.js.map